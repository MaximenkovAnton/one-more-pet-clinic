# Архитектура проекта One More Pet Clinic

## Обзор

One More Pet Clinic - это переработанная версия Spring Pet Clinic, реализованная с использованием принципов чистой архитектуры (Clean Architecture). Проект демонстрирует применение гексагональной архитектуры (также известной как "Ports and Adapters") для создания масштабируемого, тестируемого и поддерживаемого приложения.

## Гексагональная архитектура

Гексагональная архитектура, предложенная Алистером Кокберном, разделяет приложение на внутренние и внешние части:

- **Внутренняя часть** содержит бизнес-логику и правила приложения
- **Внешняя часть** содержит адаптеры для взаимодействия с внешним миром (UI, базы данных, внешние сервисы)

Эти части соединяются через порты (интерфейсы), что позволяет заменять внешние компоненты без изменения бизнес-логики.

## Слои архитектуры

Проект разделен на следующие слои:

1. **Domain** - содержит бизнес-сущности и правила. Это ядро приложения, которое не зависит ни от каких других модулей или внешних фреймворков.

2. **Application** - содержит бизнес-логику приложения, сервисы и use cases. Зависит только от модуля Domain.

3. **Port** - определяет интерфейсы и dto для взаимодействия с внешним миром:
   - **port-input**: Определяет интерфейсы, через которые внешние системы могут взаимодействовать с приложением (API).
   - **port-output**: Определяет интерфейсы, через которые приложение взаимодействует с внешними системами (репозитории, внешние сервисы).

4. **Adapter** - содержит конкретные реализации интерфейсов, определенных в Port:
   - **adapter-input**: Реализует интерфейсы из port-input (REST контроллеры, GraphQL резолверы и т.д.).
   - **adapter-output**: Реализует интерфейсы из port-output (JPA репозитории, HTTP клиенты и т.д.).

5. **Bootstrap** - собирает все вместе и содержит точку входа в приложение (main класс).

## Организация Use Cases и Портов

### Use Cases

Use Cases в нашем проекте организованы по доменным объектам и операциям:

```
application/usecase/
├── owner/
│   ├── create/
│   │   └── CreateOwnerUseCase.kt
│   ├── read/
│   │   └── ReadOwnerUseCase.kt
│   ├── update/
│   │   └── UpdateOwnerUseCase.kt
│   ├── delete/
│   │   └── DeleteOwnerUseCase.kt
│   └── list/
│       └── ListOwnerUseCase.kt
├── pet/
│   ├── create/
│   │   └── CreatePetUseCase.kt
│   └── ...
├── vet/
│   ├── create/
│   │   └── CreateVetUseCase.kt
│   └── ...
└── visit/
    ├── create/
    │   └── CreateVisitUseCase.kt
    └── ...
```

Каждый Use Case реализует соответствующий входной порт и содержит бизнес-логику для конкретной операции.

### Порты

#### Входные порты (Input Ports)

Входные порты определяют интерфейсы, через которые внешние системы взаимодействуют с приложением:

```
port/input/
├── InputPort.kt (общий функциональный интерфейс)
├── owner/
│   ├── CreateOwnerPort.kt (содержит порт, запрос и ответ)
│   ├── ReadOwnerPort.kt
│   ├── UpdateOwnerPort.kt
│   ├── DeleteOwnerPort.kt
│   └── ListOwnerPort.kt
├── pet/
│   ├── CreatePetPort.kt
│   └── ...
└── ...
```

Каждый входной порт является функциональным интерфейсом, который принимает запрос (Request) и возвращает ответ (Response).

#### Выходные порты (Output Ports)

Выходные порты определяют интерфейсы, через которые приложение взаимодействует с внешними системами:

```
port/output/
├── OutputPort.kt (общий функциональный интерфейс)
├── owner/
│   ├── SaveOwnerPort.kt (содержит порт, запрос и ответ)
│   ├── FetchOwnerPort.kt
│   ├── RemoveOwnerPort.kt
│   └── FetchAllOwnersPort.kt
├── pet/
│   ├── SavePetPort.kt
│   └── ...
└── ...
```

Выходные порты используют другие имена операций, чтобы отличать их от входных портов:
- Create/Update -> Save
- Read -> Fetch
- Delete -> Remove
- List -> FetchAll

## Вертикальный и горизонтальный слайсинг

В проекте используется комбинация вертикального и горизонтального слайсинга:

- **Горизонтальный слайсинг** - разделение на слои согласно гексагональной архитектуре (domain, application, ports, adapters)
- **Вертикальный слайсинг** - разделение на функциональные модули внутри каждого слоя (например, модули для работы с владельцами, питомцами, визитами и т.д.)

Такой подход позволяет эффективно организовать код и упрощает навигацию по проекту.

## Поток данных

1. Запрос поступает через входной адаптер (adapter-input)
2. Адаптер преобразует запрос в формат, понятный приложению, и вызывает соответствующий порт (port-input)
3. Порт делегирует выполнение use case в слое приложения (application)
4. Use case выполняет бизнес-логику, используя доменные объекты (domain)
5. При необходимости use case обращается к выходным портам (port-output) для взаимодействия с внешними системами
6. Выходные адаптеры (adapter-output) реализуют эти порты и выполняют конкретные операции (например, сохранение в базу данных)
7. Результат возвращается обратно через слои и преобразуется в формат ответа

## Преимущества архитектуры

1. **Независимость от фреймворков**: Бизнес-логика не зависит от внешних фреймворков или библиотек.
2. **Тестируемость**: Модули легко тестировать изолированно.
3. **Гибкость**: Легко заменять компоненты, не затрагивая бизнес-логику.
4. **Четкое разделение ответственности**: Каждый модуль имеет четко определенную ответственность.
