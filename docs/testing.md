# Подход к тестированию в One More Pet Clinic

## Обзор

Тестирование является неотъемлемой частью разработки One More Pet Clinic. Мы стремимся к высокому тестовому покрытию и используем различные типы тестов для обеспечения качества кода и соответствия требованиям.

## Философия тестирования

Наш подход к тестированию основан на следующих принципах:

1. **Тесты как документация** - тесты должны ясно демонстрировать, как используется код и какое поведение ожидается.
2. **Тесты как защита от регрессий** - тесты должны предотвращать появление регрессий при изменении кода.
3. **Тесты как инструмент проектирования** - тесты помогают проектировать API и интерфейсы.
4. **Тесты должны быть быстрыми** - медленные тесты замедляют разработку и редко запускаются.
5. **Тесты должны быть независимыми** - тесты не должны зависеть друг от друга.

## Предпочтение стабов вместо моков

В нашем проекте мы предпочитаем использовать стабы вместо моков по следующим причинам:

### Преимущества стабов

1. **Меньшая связанность с реализацией** - стабы проверяют поведение, а не реализацию.
2. **Более устойчивые тесты** - тесты со стабами менее хрупкие при рефакторинге.
3. **Лучшая читаемость** - тесты со стабами обычно проще и понятнее.
4. **Фокус на результате** - стабы позволяют сосредоточиться на результате, а не на взаимодействии.

### Когда мы используем моки

Несмотря на предпочтение стабов, мы используем моки в следующих случаях:

1. Когда важно проверить порядок вызовов.
2. Когда важно проверить, что определенный метод был вызван с определенными параметрами.
3. Когда важно проверить, что определенный метод не был вызван.

## Типы тестов

### Модульные тесты (Unit Tests)

- Тестируют отдельные классы или небольшие группы классов.
- Изолированы от внешних зависимостей с помощью стабов или моков.
- Быстрые и легкие в написании и поддержке.
- Покрывают все публичные методы и основные сценарии использования.

### Интеграционные тесты

- Тестируют взаимодействие между компонентами.
- Проверяют корректность интеграции между слоями приложения.
- Могут использовать реальные зависимости или их легковесные аналоги.
- Фокусируются на границах между компонентами.

### Компонентные тесты

- Тестируют отдельные компоненты системы (например, REST API, репозитории).
- Проверяют функциональность компонента как черного ящика.
- Могут использовать реальные зависимости или их заменители.
- Фокусируются на контрактах компонентов.

### Сквозные тесты (End-to-End Tests)

- Тестируют систему целиком, от пользовательского интерфейса до базы данных.
- Проверяют сценарии использования с точки зрения пользователя.
- Используют реальные зависимости или их близкие аналоги.
- Фокусируются на бизнес-сценариях.

## Инструменты тестирования

### Для модульных тестов

- JUnit 5 - основной фреймворк для тестирования
- Mockito - для создания моков и стабов
- AssertJ - для удобных и выразительных утверждений
- Kotest - для тестирования в стиле BDD

### Для интеграционных и компонентных тестов

- Spring Test - для тестирования Spring-компонентов
- Testcontainers - для запуска зависимостей в Docker-контейнерах
- REST Assured - для тестирования REST API
- WireMock - для имитации внешних HTTP-сервисов

### Для сквозных тестов

- Selenium - для тестирования веб-интерфейса
- Cucumber - для написания тестов в формате Gherkin
- Gatling - для нагрузочного тестирования

## Организация тестов

### Структура тестовых классов

- Тестовые классы следуют той же структуре, что и основной код.
- Имена тестовых классов заканчиваются на "Test" или "IT" (для интеграционных тестов).
- Тесты организованы по функциональности, а не по методам.

### Именование тестов

Мы используем шаблон "should_ExpectedBehavior_When_StateUnderTest" для именования тестов, например:

- `should_ReturnOwner_When_OwnerExists`
- `should_ThrowException_When_OwnerNotFound`
- `should_SaveOwner_When_OwnerIsValid`

### Организация кода внутри теста

Мы следуем паттерну AAA (Arrange-Act-Assert):

1. **Arrange** - подготовка данных и зависимостей
2. **Act** - выполнение тестируемого действия
3. **Assert** - проверка результатов

## Тестовое покрытие

Мы стремимся к высокому тестовому покрытию, однако, мы фокусируемся не только на количественных метриках, но и на качестве тестов и покрытии критических путей.
Для проверки качества тестирования будет использоваться механизмы мутационного тестирования.

## Тестовые данные

Мы используем фабрики для создания тестовых данных:

- Фабрики предоставляют методы для создания типичных объектов.
- Фабрики позволяют настраивать объекты для конкретных тестовых сценариев.
- Фабрики обеспечивают согласованность тестовых данных.

## Непрерывная интеграция

Все тесты запускаются в рамках процесса непрерывной интеграции.
Это обеспечивает раннее обнаружение проблем и поддержание качества кода.
